{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prostata","text":"<p>A Python library for PROcessing STATistics with timers, counters, ratios, and attributes.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Timers: Track elapsed time with start/stop functionality</li> <li>Counters: Count events with increment/decrement operations</li> <li>Ratios: Calculate ratios between counters automatically</li> <li>Attributes: Store arbitrary values and metadata</li> <li>Labels: Add descriptive labels to all statistics</li> <li>Dynamic Methods: Auto-generated methods for easy access</li> <li>Type Safety: Full type hints and validation</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from prostata import Stats\n\n# Create a stats instance\nstats = Stats()\n\n# Create a timer\nstats.set_timer(\"response_time\", \"Response Time\")\n\n# Create counters\nstats.set_counter(\"requests\", 0, \"count\", \"Total Requests\")\nstats.set_counter(\"errors\", 0, \"count\", \"Error Count\")\n\n# Start timing\nstats.start_response_time()\n\n# Simulate work\nimport time\ntime.sleep(0.1)\n\n# Increment counters\nstats.incr_requests()\nstats.incr_errors(2)\n\n# Stop timing\nstats.stop_response_time()\n\n# Get results\nprint(f\"Response time: {stats.get_response_time():.2f} seconds\")\nprint(f\"Requests: {stats.get_requests()}\")\nprint(f\"Errors: {stats.get_errors()}\")\n\n# Create a ratio\nstats.set_ratio(\"error_rate\", \"errors\", \"requests\", \"Error Rate\")\nprint(f\"Error rate: {stats.get_error_rate():.2%}\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install prostata\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"api/stats/","title":"Stats API Reference","text":""},{"location":"api/stats/#prostata.Stats","title":"<code>prostata.Stats</code>","text":""},{"location":"api/stats/#prostata.Stats.Stats","title":"<code>Stats</code>","text":"Source code in <code>prostata/Stats.py</code> <pre><code>class Stats:\n\n    def __init__(self):\n        self._timers = {}  # {name: {'start': datetime, 'stop': datetime, segments: int ,'elapsed': duration, 'label': str}}\n        self._counters = {}  # {name: {'value': amount, 'unit': unit, 'label': str}}\n        self._ratios = {}  # {name: {'numerator': name, 'denominator': name, 'value': ratio, 'label': str}}\n        self._attributes = {}  # {name: {'value': value, 'label': str}}\n        self._names_used = set()  # Track all names to ensure uniqueness\n\n    def is_used(self, name: str) -&gt; bool:\n        \"\"\"\n        Check if a name is being used across timers, counters, ratios, and attributes.\n\n        Args:\n            name (str): The name to check.\n\n        Returns:\n            bool: True if the name is used, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; stats = Stats()\n            &gt;&gt;&gt; stats.set_timer(\"load_time\")\n            &gt;&gt;&gt; stats.is_used(\"load_time\")\n            True\n            &gt;&gt;&gt; stats.is_used(\"non_existent\")\n            False\n        \"\"\"\n        return name in self._names_used\n\n    def _check_name_allowed(self, name: str):\n        \"\"\"\n        Check if the name is allowed (not a reserved word and valid format).\n        The name must consist of lowercase letters, digits, and underscores only.\n        The reserved words are: timer, counter, ratio, attribute (and their plural forms).\n\n        Args:\n            name (str): The name to check.\n\n        Returns:\n            None\n\n        Raises:\n            NameNotAllowed: If the name is a reserved word or has invalid format. The exception message details the reason.\n\n        Examples:\n            &gt;&gt;&gt; stats = Stats()\n            &gt;&gt;&gt; stats._check_name_allowed(\"valid_name\")  # No exception\n            &gt;&gt;&gt; stats._check_name_allowed(\"timer\")\n        \"\"\"\n        forbidden = [\"timer\", \"counter\", \"ratio\", \"attribute\", \"timers\", \"counters\", \"ratios\", \"attributes\"]\n        if name in forbidden:\n            raise NameNotAllowed(f\"Name '{name}' is not allowed as it is a reserved word (timer, counter, ratio, attribute are reserved).\")\n        if not re.match(r'^[a-z0-9_]+$', name):\n            raise NameNotAllowed(f\"Name '{name}' contains invalid characters. Only lowercase letters, digits, and underscores are allowed.\")\n\n    def _check_name_unique(self, name: str):\n        \"\"\" \n        Check if the name is unique across timers, counters, ratios, and attributes.\n        Args:\n            name (str): The name to check.\n        Returns:\n            None\n        Raises:\n            NameExists: If the name is already used.\n        Examples:\n            &gt;&gt;&gt; stats = Stats()\n            &gt;&gt;&gt; stats.set_timer(\"load_time\")\n            &gt;&gt;&gt; stats._check_name_unique(\"load_time\")  # Raises NameExists\n            &gt;&gt;&gt; stats._check_name_unique(\"new_name\")  # No exception\n        \"\"\"\n        if self.is_used(name):\n            raise NameExists(f\"Name '{name}' already exists. Names cannot be repeated across timers, counters, ratios, and attributes.\")\n\n    def set_timer(self, name: str, label: str = None):\n        \"\"\"\n        Create a new timer with the given name.\n\n        Args:\n            name (str): The name of the timer.\n            label (str, optional): The label for the timer. Defaults to the name if not provided.\n\n        Raises:\n            NameNotAllowed: If the name is a reserved word or has invalid format.\n            NameExists: If the name is already used.\n\n        Examples:\n            &gt;&gt;&gt; stats = Stats()\n            &gt;&gt;&gt; stats.set_timer(\"load_time\", label=\"Loading Time\")\n            &gt;&gt;&gt; stats.start_load_time()\n            &gt;&gt;&gt; # ... some code ...\n            &gt;&gt;&gt; stats.stop_load_time()\n            &gt;&gt;&gt; elapsed = stats.get_load_time()\n            &gt;&gt;&gt; print(f\"Elapsed time: {elapsed} seconds\")\n        \"\"\"\n        self._check_name_allowed(name)\n        self._check_name_unique(name)\n        if label is None:\n            label = name\n        self._timers[name] = {'start': None, 'stop': None, 'segments': 0, 'elapsed': 0.0, 'label': label}\n        self._names_used.add(name)\n        # Add dynamic methods\n        setattr(self, f'get_{name}', lambda: self.get_timer(name))\n        setattr(self, f'start_{name}', lambda: self.start_timer(name))\n        setattr(self, f'stop_{name}', lambda: self.stop_timer(name))\n\n    def set_counter(self, name: str, value: int = 0, unit: str = \"item\", label: str = None):\n        \"\"\"\n        Create a new counter with the given name, initial value, and unit.\n\n        Args:\n            name (str): The name of the counter.\n            value (int): The initial value. Defaults to 0.\n            unit (str): The unit of the counter. Defaults to \"item\".\n            label (str, optional): The label for the counter. Defaults to the name if not provided.\n\n        Raises:\n            NameNotAllowed: If the name is a reserved word or has invalid format.\n            NameExists: If the name is already used.\n        Example:\n            &gt;&gt;&gt; stats = Stats()\n            &gt;&gt;&gt; stats.set_counter(\"requests\", value=10, unit=\"requests\", label=\"Total Requests\")\n            &gt;&gt;&gt; stats.get_requests()\n            10\n            &gt;&gt;&gt; stats.incr_requests(5)\n            &gt;&gt;&gt; stats.get_requests()\n            15\n            &gt;&gt;&gt; stats.decr_requests(3)\n            &gt;&gt;&gt; stats.get_requests()\n            12\n            &gt;&gt;&gt; stats.reset_requests()\n            &gt;&gt;&gt; stats.get_requests()\n            0\n        \"\"\"\n        self._check_name_allowed(name)\n        self._check_name_unique(name)\n        if label is None:\n            label = name\n        self._counters[name] = {'value': value, 'unit': unit, 'label': label}\n        self._names_used.add(name)\n        # Add dynamic methods\n        setattr(self, f'get_{name}', lambda: self.get_counter(name))\n        setattr(self, f'incr_{name}', lambda amount=1: self.incr(name, amount))\n        setattr(self, f'decr_{name}', lambda amount=1: self.decr(name, amount))\n        setattr(self, f'reset_{name}', lambda value=0: self.reset_counter(name, value))\n\n    def set_ratio(self, name: str, numerator: str, denominator: str, label: str = None):\n        \"\"\"\n        Create a new ratio with the given name, numerator, and denominator.\n\n        Args:\n            name (str): The name of the ratio.\n            numerator (str): The name of the numerator counter.\n            denominator (str): The name of the denominator counter.\n            label (str, optional): The label for the ratio. Defaults to the name if not provided.\n\n        Raises:\n            NameNotAllowed: If the name is a reserved word or has invalid format.\n            NameExists: If the name is already used.\n            NameNotExists: If numerator or denominator do not exist.\n\n        Examples:\n            &gt;&gt;&gt; stats = Stats()\n            &gt;&gt;&gt; stats.set_counter(\"success_count\")\n            &gt;&gt;&gt; stats.set_counter(\"total_count\")\n            &gt;&gt;&gt; stats.set_ratio(\"success_rate\", \"success_count\", \"total_count\", label=\"Success Rate\")\n            &gt;&gt;&gt; stats.incr_success_count(80)\n            &gt;&gt;&gt; stats.incr_total_count(100)\n            &gt;&gt;&gt; rate = stats.get_success_rate()\n            &gt;&gt;&gt; print(f\"Success Rate: {rate}\")\n        \"\"\"\n        self._check_name_allowed(name)\n        self._check_name_unique(name)\n        if not self.is_used(numerator):\n            raise NameNotExists(f\"Numerator '{numerator}' does not exist.\")\n        if not self.is_used(denominator):\n            raise NameNotExists(f\"Denominator '{denominator}' does not exist.\")\n        if label is None:\n            label = name\n        self._ratios[name] = {'numerator': numerator, 'denominator': denominator, 'value': 0.0, 'label': label}\n        self._names_used.add(name)\n        # Add dynamic method\n        setattr(self, f'get_{name}', lambda: self.get_ratio(name))\n\n    def set_attribute(self, name: str, value: Union[str, int, float] = \"\", label: str = None):\n        \"\"\"\n        Create a new attribute with the given name and value.\n\n        Args:\n            name (str): The name of the attribute.\n            value (Union[str, int, float]): The value of the attribute. Defaults to \"\".\n            label (str, optional): The label for the attribute. Defaults to the name if not provided.\n\n        Raises:\n            NameNotAllowed: If the name is a reserved word or has invalid format.\n            NameExists: If the name is already used.\n        Examples:\n            &gt;&gt;&gt; stats = Stats()\n            &gt;&gt;&gt; stats.set_attribute(\"version\", \"1.0.0\", label=\"Software Version\")\n            &gt;&gt;&gt; stats.get_version()\n            '1.0.0'\n            &gt;&gt;&gt; stats.set_version(\"1.1.0\")\n            &gt;&gt;&gt; stats.get_version()\n            '1.1.0' \n            &gt;&gt;&gt; stats.set_attribute(\"build_number\", 42)\n            &gt;&gt;&gt; stats.get_build_number()\n            42\n            &gt;&gt;&gt; stats.set_attribute(\"pi_value\", 3.14159)\n            &gt;&gt;&gt; stats.get_pi_value()\n            3.14159 \n        \"\"\"\n        self._check_name_allowed(name)\n        self._check_name_unique(name)\n        if label is None:\n            label = name\n        self._attributes[name] = {'value': value, 'label': label}\n        self._names_used.add(name)\n        # Add dynamic method\n        setattr(self, f'get_{name}', lambda: self.get_attribute(name))\n        setattr(self, f'set_{name}', lambda value: self.set_attribute_value(name, value))\n\n    def get_timer(self, name: str) -&gt; float:\n        \"\"\"\n        Get the elapsed time in seconds for the timer.\n\n        Args:\n            name (str): The name of the timer.\n\n        Returns:\n            float: The elapsed time in seconds. Returns 0 if never started.\n\n        Raises:\n            NameNotExists: If the timer does not exist.\n        \"\"\"\n        if name not in self._timers:\n            raise NameNotExists(f\"Timer '{name}' does not exist.\")\n        timer = self._timers[name]\n        elapsed = timer['elapsed']\n        if timer['start'] is not None:\n            elapsed += (datetime.now() - timer['start']).total_seconds()\n        return elapsed\n\n    def start_timer(self, name: str):\n        \"\"\"\n        Start the timer.\n\n        Args:\n            name (str): The name of the timer.\n\n        Raises:\n            NameNotExists: If the timer does not exist.\n        \"\"\"\n        if name not in self._timers:\n            raise NameNotExists(f\"Timer '{name}' does not exist.\")\n        timer = self._timers[name]\n        if timer['start'] is None:\n            timer['start'] = datetime.now()\n            timer['segments'] += 1\n\n    def stop_timer(self, name: str):\n        \"\"\"\n        Stop the timer and accumulate elapsed time.\n\n        Args:\n            name (str): The name of the timer.\n\n        Raises:\n            NameNotExists: If the timer does not exist.\n        \"\"\"\n        if name not in self._timers:\n            raise NameNotExists(f\"Timer '{name}' does not exist.\")\n        timer = self._timers[name]\n        if timer['start'] is not None:\n            now = datetime.now()\n            timer['elapsed'] += (now - timer['start']).total_seconds()\n            timer['stop'] = now\n            timer['start'] = None\n\n    def get_counter(self, name: str) -&gt; int:\n        \"\"\"\n        Get the value of the counter.\n\n        Args:\n            name (str): The name of the counter.\n\n        Returns:\n            int: The value of the counter.\n\n        Raises:\n            NameNotExists: If the counter does not exist.\n        \"\"\"\n        if name not in self._counters:\n            raise NameNotExists(f\"Counter '{name}' does not exist.\")\n        return self._counters[name]['value']\n\n    def incr(self, name: str, amount: int = 1):\n        \"\"\"\n        Increment the counter by the given amount.\n\n        Args:\n            name (str): The name of the counter.\n            amount (int): The amount to increment. Defaults to 1.\n\n        Raises:\n            NameNotExists: If the counter does not exist.\n        \"\"\"\n        if name not in self._counters:\n            raise NameNotExists(f\"Counter '{name}' does not exist.\")\n        self._counters[name]['value'] += amount\n\n    def decr(self, name: str, amount: int = 1):\n        \"\"\"\n        Decrement the counter by the given amount.\n\n        Args:\n            name (str): The name of the counter.\n            amount (int): The amount to decrement. Defaults to 1.\n\n        Raises:\n            NameNotExists: If the counter does not exist.\n        \"\"\"\n        if name not in self._counters:\n            raise NameNotExists(f\"Counter '{name}' does not exist.\")\n        self._counters[name]['value'] -= amount\n\n    def reset_counter(self, name: str, value: int = 0):\n        \"\"\"\n        Reset the counter to the given value.\n\n        Args:\n            name (str): The name of the counter.\n            value (int): The value to reset to. Defaults to 0.\n\n        Raises:\n            NameNotExists: If the counter does not exist.\n        \"\"\"\n        if name not in self._counters:\n            raise NameNotExists(f\"Counter '{name}' does not exist.\")\n        self._counters[name]['value'] = value\n\n    def set_counter_unit(self, name: str, unit: str):\n        \"\"\"\n        Set the unit of the counter.\n\n        Args:\n            name (str): The name of the counter.\n            unit (str): The new unit.\n\n        Raises:\n            NameNotExists: If the counter does not exist.\n        \"\"\"\n        if name not in self._counters:\n            raise NameNotExists(f\"Counter '{name}' does not exist.\")\n        self._counters[name]['unit'] = unit\n\n    def get_ratio(self, name: str) -&gt; float:\n        \"\"\"\n        Get the value of the ratio.\n\n        Args:\n            name (str): The name of the ratio.\n\n        Returns:\n            float: The ratio value. Returns 0 if denominator is 0.\n\n        Raises:\n            NameNotExists: If the ratio does not exist.\n        \"\"\"\n        if name not in self._ratios:\n            raise NameNotExists(f\"Ratio '{name}' does not exist.\")\n        ratio = self._ratios[name]\n        num_value = self.get_counter(ratio['numerator'])\n        den_value = self.get_counter(ratio['denominator'])\n        if den_value == 0:\n            return 0.0\n        return num_value / den_value\n\n    def get_attribute(self, name: str) -&gt; Union[str, int, float]:\n        \"\"\"\n        Get the value of the attribute.\n\n        Args:\n            name (str): The name of the attribute.\n\n        Returns:\n            Union[str, int, float]: The value of the attribute.\n\n        Raises:\n            NameNotExists: If the attribute does not exist.\n        \"\"\"\n        if name not in self._attributes:\n            raise NameNotExists(f\"Attribute '{name}' does not exist.\")\n        return self._attributes[name]['value']\n\n    def set_attribute_value(self, name: str, value: Union[str, int, float]):\n        \"\"\"\n        Set the value of the attribute.\n\n        Args:\n            name (str): The name of the attribute.\n            value (Union[str, int, float]): The new value.\n\n        Raises:\n            NameNotExists: If the attribute does not exist.\n        \"\"\"\n        if name not in self._attributes:\n            raise NameNotExists(f\"Attribute '{name}' does not exist.\")\n        self._attributes[name]['value'] = value\n\n    def get_timers(self) -&gt; dict:\n        \"\"\"\n        Get all timers.\n\n        Returns:\n            dict: A copy of the timers dictionary.\n        \"\"\"\n        return self._timers.copy()\n\n    def get_counters(self) -&gt; dict:\n        \"\"\"\n        Get all counters.\n\n        Returns:\n            dict: A copy of the counters dictionary.\n        \"\"\"\n        return self._counters.copy()\n\n    def get_ratios(self) -&gt; dict:\n        \"\"\"\n        Get all ratios.\n\n        Returns:\n            dict: A copy of the ratios dictionary.\n        \"\"\"\n        return self._ratios.copy()\n\n    def get_attributes(self) -&gt; dict:\n        \"\"\"\n        Get all attributes.\n\n        Returns:\n            dict: A copy of the attributes dictionary.\n        \"\"\"\n        return self._attributes.copy()\n\n    def timer_names(self) -&gt; list:\n        \"\"\"\n        Get the list of timer names.\n\n        Returns:\n            list: A list of timer names.\n        \"\"\"\n        return list(self._timers.keys())\n\n    def counter_names(self) -&gt; list:\n        \"\"\"\n        Get the list of counter names.\n\n        Returns:\n            list: A list of counter names.\n        \"\"\"\n        return list(self._counters.keys())\n\n    def ratio_names(self) -&gt; list:\n        \"\"\"\n        Get the list of ratio names.\n\n        Returns:\n            list: A list of ratio names.\n        \"\"\"\n        return list(self._ratios.keys())\n\n    def attribute_names(self) -&gt; list:\n        \"\"\"\n        Get the list of attribute names.\n\n        Returns:\n            list: A list of attribute names.\n        \"\"\"\n        return list(self._attributes.keys())\n\n    def used_names(self) -&gt; list:\n        \"\"\"\n        Get the list of all used names.\n\n        Returns:\n            list: A list of all used names across timers, counters, ratios, and attributes.\n        \"\"\"\n        return list(self._names_used)\n\n    def set_label(self, name: str, new_label: str):\n        \"\"\"\n        Set a new label for an existing timer, counter, ratio, or attribute.\n\n        Args:\n            name (str): The name of the item to update.\n            new_label (str): The new label to set.\n\n        Raises:\n            NameNotExists: If the name does not exist.\n        \"\"\"\n        if not self.is_used(name):\n            raise NameNotExists(f\"Name '{name}' does not exist.\")\n\n        if name in self._timers:\n            self._timers[name]['label'] = new_label\n        elif name in self._counters:\n            self._counters[name]['label'] = new_label\n        elif name in self._ratios:\n            self._ratios[name]['label'] = new_label\n        elif name in self._attributes:\n            self._attributes[name]['label'] = new_label\n\n    def get_labels(self) -&gt; dict:\n        \"\"\"\n        Get all name/label pairs for all items.\n\n        Returns:\n            dict: A dictionary mapping names to their labels.\n        \"\"\"\n        labels = {}\n        for name, timer in self._timers.items():\n            labels[name] = timer['label']\n        for name, counter in self._counters.items():\n            labels[name] = counter['label']\n        for name, ratio in self._ratios.items():\n            labels[name] = ratio['label']\n        for name, attr in self._attributes.items():\n            labels[name] = attr['label']\n        return labels\n\n    def get_labels_for_timers(self) -&gt; dict:\n        \"\"\"\n        Get all name/label pairs for timers.\n\n        Returns:\n            dict: A dictionary mapping timer names to their labels.\n        \"\"\"\n        return {name: timer['label'] for name, timer in self._timers.items()}\n\n    def get_labels_for_counters(self) -&gt; dict:\n        \"\"\"\n        Get all name/label pairs for counters.\n\n        Returns:\n            dict: A dictionary mapping counter names to their labels.\n        \"\"\"\n        return {name: counter['label'] for name, counter in self._counters.items()}\n\n    def get_labels_for_ratios(self) -&gt; dict:\n        \"\"\"\n        Get all name/label pairs for ratios.\n\n        Returns:\n            dict: A dictionary mapping ratio names to their labels.\n        \"\"\"\n        return {name: ratio['label'] for name, ratio in self._ratios.items()}\n\n    def get_labels_for_attributes(self) -&gt; dict:\n        \"\"\"\n        Get all name/label pairs for attributes.\n\n        Returns:\n            dict: A dictionary mapping attribute names to their labels.\n        \"\"\"\n        return {name: attr['label'] for name, attr in self._attributes.items()}\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.attribute_names","title":"<code>attribute_names()</code>","text":"<p>Get the list of attribute names.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of attribute names.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def attribute_names(self) -&gt; list:\n    \"\"\"\n    Get the list of attribute names.\n\n    Returns:\n        list: A list of attribute names.\n    \"\"\"\n    return list(self._attributes.keys())\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.counter_names","title":"<code>counter_names()</code>","text":"<p>Get the list of counter names.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of counter names.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def counter_names(self) -&gt; list:\n    \"\"\"\n    Get the list of counter names.\n\n    Returns:\n        list: A list of counter names.\n    \"\"\"\n    return list(self._counters.keys())\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.decr","title":"<code>decr(name, amount=1)</code>","text":"<p>Decrement the counter by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the counter.</p> required <code>amount</code> <code>int</code> <p>The amount to decrement. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the counter does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def decr(self, name: str, amount: int = 1):\n    \"\"\"\n    Decrement the counter by the given amount.\n\n    Args:\n        name (str): The name of the counter.\n        amount (int): The amount to decrement. Defaults to 1.\n\n    Raises:\n        NameNotExists: If the counter does not exist.\n    \"\"\"\n    if name not in self._counters:\n        raise NameNotExists(f\"Counter '{name}' does not exist.\")\n    self._counters[name]['value'] -= amount\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_attribute","title":"<code>get_attribute(name)</code>","text":"<p>Get the value of the attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute.</p> required <p>Returns:</p> Type Description <code>Union[str, int, float]</code> <p>Union[str, int, float]: The value of the attribute.</p> <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the attribute does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_attribute(self, name: str) -&gt; Union[str, int, float]:\n    \"\"\"\n    Get the value of the attribute.\n\n    Args:\n        name (str): The name of the attribute.\n\n    Returns:\n        Union[str, int, float]: The value of the attribute.\n\n    Raises:\n        NameNotExists: If the attribute does not exist.\n    \"\"\"\n    if name not in self._attributes:\n        raise NameNotExists(f\"Attribute '{name}' does not exist.\")\n    return self._attributes[name]['value']\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_attributes","title":"<code>get_attributes()</code>","text":"<p>Get all attributes.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A copy of the attributes dictionary.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_attributes(self) -&gt; dict:\n    \"\"\"\n    Get all attributes.\n\n    Returns:\n        dict: A copy of the attributes dictionary.\n    \"\"\"\n    return self._attributes.copy()\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_counter","title":"<code>get_counter(name)</code>","text":"<p>Get the value of the counter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the counter.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of the counter.</p> <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the counter does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_counter(self, name: str) -&gt; int:\n    \"\"\"\n    Get the value of the counter.\n\n    Args:\n        name (str): The name of the counter.\n\n    Returns:\n        int: The value of the counter.\n\n    Raises:\n        NameNotExists: If the counter does not exist.\n    \"\"\"\n    if name not in self._counters:\n        raise NameNotExists(f\"Counter '{name}' does not exist.\")\n    return self._counters[name]['value']\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_counters","title":"<code>get_counters()</code>","text":"<p>Get all counters.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A copy of the counters dictionary.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_counters(self) -&gt; dict:\n    \"\"\"\n    Get all counters.\n\n    Returns:\n        dict: A copy of the counters dictionary.\n    \"\"\"\n    return self._counters.copy()\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_labels","title":"<code>get_labels()</code>","text":"<p>Get all name/label pairs for all items.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping names to their labels.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_labels(self) -&gt; dict:\n    \"\"\"\n    Get all name/label pairs for all items.\n\n    Returns:\n        dict: A dictionary mapping names to their labels.\n    \"\"\"\n    labels = {}\n    for name, timer in self._timers.items():\n        labels[name] = timer['label']\n    for name, counter in self._counters.items():\n        labels[name] = counter['label']\n    for name, ratio in self._ratios.items():\n        labels[name] = ratio['label']\n    for name, attr in self._attributes.items():\n        labels[name] = attr['label']\n    return labels\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_labels_for_attributes","title":"<code>get_labels_for_attributes()</code>","text":"<p>Get all name/label pairs for attributes.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping attribute names to their labels.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_labels_for_attributes(self) -&gt; dict:\n    \"\"\"\n    Get all name/label pairs for attributes.\n\n    Returns:\n        dict: A dictionary mapping attribute names to their labels.\n    \"\"\"\n    return {name: attr['label'] for name, attr in self._attributes.items()}\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_labels_for_counters","title":"<code>get_labels_for_counters()</code>","text":"<p>Get all name/label pairs for counters.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping counter names to their labels.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_labels_for_counters(self) -&gt; dict:\n    \"\"\"\n    Get all name/label pairs for counters.\n\n    Returns:\n        dict: A dictionary mapping counter names to their labels.\n    \"\"\"\n    return {name: counter['label'] for name, counter in self._counters.items()}\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_labels_for_ratios","title":"<code>get_labels_for_ratios()</code>","text":"<p>Get all name/label pairs for ratios.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping ratio names to their labels.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_labels_for_ratios(self) -&gt; dict:\n    \"\"\"\n    Get all name/label pairs for ratios.\n\n    Returns:\n        dict: A dictionary mapping ratio names to their labels.\n    \"\"\"\n    return {name: ratio['label'] for name, ratio in self._ratios.items()}\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_labels_for_timers","title":"<code>get_labels_for_timers()</code>","text":"<p>Get all name/label pairs for timers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping timer names to their labels.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_labels_for_timers(self) -&gt; dict:\n    \"\"\"\n    Get all name/label pairs for timers.\n\n    Returns:\n        dict: A dictionary mapping timer names to their labels.\n    \"\"\"\n    return {name: timer['label'] for name, timer in self._timers.items()}\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_ratio","title":"<code>get_ratio(name)</code>","text":"<p>Get the value of the ratio.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the ratio.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The ratio value. Returns 0 if denominator is 0.</p> <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the ratio does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_ratio(self, name: str) -&gt; float:\n    \"\"\"\n    Get the value of the ratio.\n\n    Args:\n        name (str): The name of the ratio.\n\n    Returns:\n        float: The ratio value. Returns 0 if denominator is 0.\n\n    Raises:\n        NameNotExists: If the ratio does not exist.\n    \"\"\"\n    if name not in self._ratios:\n        raise NameNotExists(f\"Ratio '{name}' does not exist.\")\n    ratio = self._ratios[name]\n    num_value = self.get_counter(ratio['numerator'])\n    den_value = self.get_counter(ratio['denominator'])\n    if den_value == 0:\n        return 0.0\n    return num_value / den_value\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_ratios","title":"<code>get_ratios()</code>","text":"<p>Get all ratios.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A copy of the ratios dictionary.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_ratios(self) -&gt; dict:\n    \"\"\"\n    Get all ratios.\n\n    Returns:\n        dict: A copy of the ratios dictionary.\n    \"\"\"\n    return self._ratios.copy()\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_timer","title":"<code>get_timer(name)</code>","text":"<p>Get the elapsed time in seconds for the timer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the timer.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The elapsed time in seconds. Returns 0 if never started.</p> <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the timer does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_timer(self, name: str) -&gt; float:\n    \"\"\"\n    Get the elapsed time in seconds for the timer.\n\n    Args:\n        name (str): The name of the timer.\n\n    Returns:\n        float: The elapsed time in seconds. Returns 0 if never started.\n\n    Raises:\n        NameNotExists: If the timer does not exist.\n    \"\"\"\n    if name not in self._timers:\n        raise NameNotExists(f\"Timer '{name}' does not exist.\")\n    timer = self._timers[name]\n    elapsed = timer['elapsed']\n    if timer['start'] is not None:\n        elapsed += (datetime.now() - timer['start']).total_seconds()\n    return elapsed\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.get_timers","title":"<code>get_timers()</code>","text":"<p>Get all timers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A copy of the timers dictionary.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def get_timers(self) -&gt; dict:\n    \"\"\"\n    Get all timers.\n\n    Returns:\n        dict: A copy of the timers dictionary.\n    \"\"\"\n    return self._timers.copy()\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.incr","title":"<code>incr(name, amount=1)</code>","text":"<p>Increment the counter by the given amount.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the counter.</p> required <code>amount</code> <code>int</code> <p>The amount to increment. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the counter does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def incr(self, name: str, amount: int = 1):\n    \"\"\"\n    Increment the counter by the given amount.\n\n    Args:\n        name (str): The name of the counter.\n        amount (int): The amount to increment. Defaults to 1.\n\n    Raises:\n        NameNotExists: If the counter does not exist.\n    \"\"\"\n    if name not in self._counters:\n        raise NameNotExists(f\"Counter '{name}' does not exist.\")\n    self._counters[name]['value'] += amount\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.is_used","title":"<code>is_used(name)</code>","text":"<p>Check if a name is being used across timers, counters, ratios, and attributes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the name is used, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stats = Stats()\n&gt;&gt;&gt; stats.set_timer(\"load_time\")\n&gt;&gt;&gt; stats.is_used(\"load_time\")\nTrue\n&gt;&gt;&gt; stats.is_used(\"non_existent\")\nFalse\n</code></pre> Source code in <code>prostata/Stats.py</code> <pre><code>def is_used(self, name: str) -&gt; bool:\n    \"\"\"\n    Check if a name is being used across timers, counters, ratios, and attributes.\n\n    Args:\n        name (str): The name to check.\n\n    Returns:\n        bool: True if the name is used, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; stats = Stats()\n        &gt;&gt;&gt; stats.set_timer(\"load_time\")\n        &gt;&gt;&gt; stats.is_used(\"load_time\")\n        True\n        &gt;&gt;&gt; stats.is_used(\"non_existent\")\n        False\n    \"\"\"\n    return name in self._names_used\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.ratio_names","title":"<code>ratio_names()</code>","text":"<p>Get the list of ratio names.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of ratio names.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def ratio_names(self) -&gt; list:\n    \"\"\"\n    Get the list of ratio names.\n\n    Returns:\n        list: A list of ratio names.\n    \"\"\"\n    return list(self._ratios.keys())\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.reset_counter","title":"<code>reset_counter(name, value=0)</code>","text":"<p>Reset the counter to the given value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the counter.</p> required <code>value</code> <code>int</code> <p>The value to reset to. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the counter does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def reset_counter(self, name: str, value: int = 0):\n    \"\"\"\n    Reset the counter to the given value.\n\n    Args:\n        name (str): The name of the counter.\n        value (int): The value to reset to. Defaults to 0.\n\n    Raises:\n        NameNotExists: If the counter does not exist.\n    \"\"\"\n    if name not in self._counters:\n        raise NameNotExists(f\"Counter '{name}' does not exist.\")\n    self._counters[name]['value'] = value\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.set_attribute","title":"<code>set_attribute(name, value='', label=None)</code>","text":"<p>Create a new attribute with the given name and value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute.</p> required <code>value</code> <code>Union[str, int, float]</code> <p>The value of the attribute. Defaults to \"\".</p> <code>''</code> <code>label</code> <code>str</code> <p>The label for the attribute. Defaults to the name if not provided.</p> <code>None</code> <p>Raises:</p> Type Description <code>NameNotAllowed</code> <p>If the name is a reserved word or has invalid format.</p> <code>NameExists</code> <p>If the name is already used.</p> <p>Examples:     &gt;&gt;&gt; stats = Stats()     &gt;&gt;&gt; stats.set_attribute(\"version\", \"1.0.0\", label=\"Software Version\")     &gt;&gt;&gt; stats.get_version()     '1.0.0'     &gt;&gt;&gt; stats.set_version(\"1.1.0\")     &gt;&gt;&gt; stats.get_version()     '1.1.0'      &gt;&gt;&gt; stats.set_attribute(\"build_number\", 42)     &gt;&gt;&gt; stats.get_build_number()     42     &gt;&gt;&gt; stats.set_attribute(\"pi_value\", 3.14159)     &gt;&gt;&gt; stats.get_pi_value()     3.14159</p> Source code in <code>prostata/Stats.py</code> <pre><code>def set_attribute(self, name: str, value: Union[str, int, float] = \"\", label: str = None):\n    \"\"\"\n    Create a new attribute with the given name and value.\n\n    Args:\n        name (str): The name of the attribute.\n        value (Union[str, int, float]): The value of the attribute. Defaults to \"\".\n        label (str, optional): The label for the attribute. Defaults to the name if not provided.\n\n    Raises:\n        NameNotAllowed: If the name is a reserved word or has invalid format.\n        NameExists: If the name is already used.\n    Examples:\n        &gt;&gt;&gt; stats = Stats()\n        &gt;&gt;&gt; stats.set_attribute(\"version\", \"1.0.0\", label=\"Software Version\")\n        &gt;&gt;&gt; stats.get_version()\n        '1.0.0'\n        &gt;&gt;&gt; stats.set_version(\"1.1.0\")\n        &gt;&gt;&gt; stats.get_version()\n        '1.1.0' \n        &gt;&gt;&gt; stats.set_attribute(\"build_number\", 42)\n        &gt;&gt;&gt; stats.get_build_number()\n        42\n        &gt;&gt;&gt; stats.set_attribute(\"pi_value\", 3.14159)\n        &gt;&gt;&gt; stats.get_pi_value()\n        3.14159 \n    \"\"\"\n    self._check_name_allowed(name)\n    self._check_name_unique(name)\n    if label is None:\n        label = name\n    self._attributes[name] = {'value': value, 'label': label}\n    self._names_used.add(name)\n    # Add dynamic method\n    setattr(self, f'get_{name}', lambda: self.get_attribute(name))\n    setattr(self, f'set_{name}', lambda value: self.set_attribute_value(name, value))\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.set_attribute_value","title":"<code>set_attribute_value(name, value)</code>","text":"<p>Set the value of the attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute.</p> required <code>value</code> <code>Union[str, int, float]</code> <p>The new value.</p> required <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the attribute does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def set_attribute_value(self, name: str, value: Union[str, int, float]):\n    \"\"\"\n    Set the value of the attribute.\n\n    Args:\n        name (str): The name of the attribute.\n        value (Union[str, int, float]): The new value.\n\n    Raises:\n        NameNotExists: If the attribute does not exist.\n    \"\"\"\n    if name not in self._attributes:\n        raise NameNotExists(f\"Attribute '{name}' does not exist.\")\n    self._attributes[name]['value'] = value\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.set_counter","title":"<code>set_counter(name, value=0, unit='item', label=None)</code>","text":"<p>Create a new counter with the given name, initial value, and unit.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the counter.</p> required <code>value</code> <code>int</code> <p>The initial value. Defaults to 0.</p> <code>0</code> <code>unit</code> <code>str</code> <p>The unit of the counter. Defaults to \"item\".</p> <code>'item'</code> <code>label</code> <code>str</code> <p>The label for the counter. Defaults to the name if not provided.</p> <code>None</code> <p>Raises:</p> Type Description <code>NameNotAllowed</code> <p>If the name is a reserved word or has invalid format.</p> <code>NameExists</code> <p>If the name is already used.</p> <p>Example:     &gt;&gt;&gt; stats = Stats()     &gt;&gt;&gt; stats.set_counter(\"requests\", value=10, unit=\"requests\", label=\"Total Requests\")     &gt;&gt;&gt; stats.get_requests()     10     &gt;&gt;&gt; stats.incr_requests(5)     &gt;&gt;&gt; stats.get_requests()     15     &gt;&gt;&gt; stats.decr_requests(3)     &gt;&gt;&gt; stats.get_requests()     12     &gt;&gt;&gt; stats.reset_requests()     &gt;&gt;&gt; stats.get_requests()     0</p> Source code in <code>prostata/Stats.py</code> <pre><code>def set_counter(self, name: str, value: int = 0, unit: str = \"item\", label: str = None):\n    \"\"\"\n    Create a new counter with the given name, initial value, and unit.\n\n    Args:\n        name (str): The name of the counter.\n        value (int): The initial value. Defaults to 0.\n        unit (str): The unit of the counter. Defaults to \"item\".\n        label (str, optional): The label for the counter. Defaults to the name if not provided.\n\n    Raises:\n        NameNotAllowed: If the name is a reserved word or has invalid format.\n        NameExists: If the name is already used.\n    Example:\n        &gt;&gt;&gt; stats = Stats()\n        &gt;&gt;&gt; stats.set_counter(\"requests\", value=10, unit=\"requests\", label=\"Total Requests\")\n        &gt;&gt;&gt; stats.get_requests()\n        10\n        &gt;&gt;&gt; stats.incr_requests(5)\n        &gt;&gt;&gt; stats.get_requests()\n        15\n        &gt;&gt;&gt; stats.decr_requests(3)\n        &gt;&gt;&gt; stats.get_requests()\n        12\n        &gt;&gt;&gt; stats.reset_requests()\n        &gt;&gt;&gt; stats.get_requests()\n        0\n    \"\"\"\n    self._check_name_allowed(name)\n    self._check_name_unique(name)\n    if label is None:\n        label = name\n    self._counters[name] = {'value': value, 'unit': unit, 'label': label}\n    self._names_used.add(name)\n    # Add dynamic methods\n    setattr(self, f'get_{name}', lambda: self.get_counter(name))\n    setattr(self, f'incr_{name}', lambda amount=1: self.incr(name, amount))\n    setattr(self, f'decr_{name}', lambda amount=1: self.decr(name, amount))\n    setattr(self, f'reset_{name}', lambda value=0: self.reset_counter(name, value))\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.set_counter_unit","title":"<code>set_counter_unit(name, unit)</code>","text":"<p>Set the unit of the counter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the counter.</p> required <code>unit</code> <code>str</code> <p>The new unit.</p> required <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the counter does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def set_counter_unit(self, name: str, unit: str):\n    \"\"\"\n    Set the unit of the counter.\n\n    Args:\n        name (str): The name of the counter.\n        unit (str): The new unit.\n\n    Raises:\n        NameNotExists: If the counter does not exist.\n    \"\"\"\n    if name not in self._counters:\n        raise NameNotExists(f\"Counter '{name}' does not exist.\")\n    self._counters[name]['unit'] = unit\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.set_label","title":"<code>set_label(name, new_label)</code>","text":"<p>Set a new label for an existing timer, counter, ratio, or attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the item to update.</p> required <code>new_label</code> <code>str</code> <p>The new label to set.</p> required <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the name does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def set_label(self, name: str, new_label: str):\n    \"\"\"\n    Set a new label for an existing timer, counter, ratio, or attribute.\n\n    Args:\n        name (str): The name of the item to update.\n        new_label (str): The new label to set.\n\n    Raises:\n        NameNotExists: If the name does not exist.\n    \"\"\"\n    if not self.is_used(name):\n        raise NameNotExists(f\"Name '{name}' does not exist.\")\n\n    if name in self._timers:\n        self._timers[name]['label'] = new_label\n    elif name in self._counters:\n        self._counters[name]['label'] = new_label\n    elif name in self._ratios:\n        self._ratios[name]['label'] = new_label\n    elif name in self._attributes:\n        self._attributes[name]['label'] = new_label\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.set_ratio","title":"<code>set_ratio(name, numerator, denominator, label=None)</code>","text":"<p>Create a new ratio with the given name, numerator, and denominator.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the ratio.</p> required <code>numerator</code> <code>str</code> <p>The name of the numerator counter.</p> required <code>denominator</code> <code>str</code> <p>The name of the denominator counter.</p> required <code>label</code> <code>str</code> <p>The label for the ratio. Defaults to the name if not provided.</p> <code>None</code> <p>Raises:</p> Type Description <code>NameNotAllowed</code> <p>If the name is a reserved word or has invalid format.</p> <code>NameExists</code> <p>If the name is already used.</p> <code>NameNotExists</code> <p>If numerator or denominator do not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stats = Stats()\n&gt;&gt;&gt; stats.set_counter(\"success_count\")\n&gt;&gt;&gt; stats.set_counter(\"total_count\")\n&gt;&gt;&gt; stats.set_ratio(\"success_rate\", \"success_count\", \"total_count\", label=\"Success Rate\")\n&gt;&gt;&gt; stats.incr_success_count(80)\n&gt;&gt;&gt; stats.incr_total_count(100)\n&gt;&gt;&gt; rate = stats.get_success_rate()\n&gt;&gt;&gt; print(f\"Success Rate: {rate}\")\n</code></pre> Source code in <code>prostata/Stats.py</code> <pre><code>def set_ratio(self, name: str, numerator: str, denominator: str, label: str = None):\n    \"\"\"\n    Create a new ratio with the given name, numerator, and denominator.\n\n    Args:\n        name (str): The name of the ratio.\n        numerator (str): The name of the numerator counter.\n        denominator (str): The name of the denominator counter.\n        label (str, optional): The label for the ratio. Defaults to the name if not provided.\n\n    Raises:\n        NameNotAllowed: If the name is a reserved word or has invalid format.\n        NameExists: If the name is already used.\n        NameNotExists: If numerator or denominator do not exist.\n\n    Examples:\n        &gt;&gt;&gt; stats = Stats()\n        &gt;&gt;&gt; stats.set_counter(\"success_count\")\n        &gt;&gt;&gt; stats.set_counter(\"total_count\")\n        &gt;&gt;&gt; stats.set_ratio(\"success_rate\", \"success_count\", \"total_count\", label=\"Success Rate\")\n        &gt;&gt;&gt; stats.incr_success_count(80)\n        &gt;&gt;&gt; stats.incr_total_count(100)\n        &gt;&gt;&gt; rate = stats.get_success_rate()\n        &gt;&gt;&gt; print(f\"Success Rate: {rate}\")\n    \"\"\"\n    self._check_name_allowed(name)\n    self._check_name_unique(name)\n    if not self.is_used(numerator):\n        raise NameNotExists(f\"Numerator '{numerator}' does not exist.\")\n    if not self.is_used(denominator):\n        raise NameNotExists(f\"Denominator '{denominator}' does not exist.\")\n    if label is None:\n        label = name\n    self._ratios[name] = {'numerator': numerator, 'denominator': denominator, 'value': 0.0, 'label': label}\n    self._names_used.add(name)\n    # Add dynamic method\n    setattr(self, f'get_{name}', lambda: self.get_ratio(name))\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.set_timer","title":"<code>set_timer(name, label=None)</code>","text":"<p>Create a new timer with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the timer.</p> required <code>label</code> <code>str</code> <p>The label for the timer. Defaults to the name if not provided.</p> <code>None</code> <p>Raises:</p> Type Description <code>NameNotAllowed</code> <p>If the name is a reserved word or has invalid format.</p> <code>NameExists</code> <p>If the name is already used.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stats = Stats()\n&gt;&gt;&gt; stats.set_timer(\"load_time\", label=\"Loading Time\")\n&gt;&gt;&gt; stats.start_load_time()\n&gt;&gt;&gt; # ... some code ...\n&gt;&gt;&gt; stats.stop_load_time()\n&gt;&gt;&gt; elapsed = stats.get_load_time()\n&gt;&gt;&gt; print(f\"Elapsed time: {elapsed} seconds\")\n</code></pre> Source code in <code>prostata/Stats.py</code> <pre><code>def set_timer(self, name: str, label: str = None):\n    \"\"\"\n    Create a new timer with the given name.\n\n    Args:\n        name (str): The name of the timer.\n        label (str, optional): The label for the timer. Defaults to the name if not provided.\n\n    Raises:\n        NameNotAllowed: If the name is a reserved word or has invalid format.\n        NameExists: If the name is already used.\n\n    Examples:\n        &gt;&gt;&gt; stats = Stats()\n        &gt;&gt;&gt; stats.set_timer(\"load_time\", label=\"Loading Time\")\n        &gt;&gt;&gt; stats.start_load_time()\n        &gt;&gt;&gt; # ... some code ...\n        &gt;&gt;&gt; stats.stop_load_time()\n        &gt;&gt;&gt; elapsed = stats.get_load_time()\n        &gt;&gt;&gt; print(f\"Elapsed time: {elapsed} seconds\")\n    \"\"\"\n    self._check_name_allowed(name)\n    self._check_name_unique(name)\n    if label is None:\n        label = name\n    self._timers[name] = {'start': None, 'stop': None, 'segments': 0, 'elapsed': 0.0, 'label': label}\n    self._names_used.add(name)\n    # Add dynamic methods\n    setattr(self, f'get_{name}', lambda: self.get_timer(name))\n    setattr(self, f'start_{name}', lambda: self.start_timer(name))\n    setattr(self, f'stop_{name}', lambda: self.stop_timer(name))\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.start_timer","title":"<code>start_timer(name)</code>","text":"<p>Start the timer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the timer.</p> required <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the timer does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def start_timer(self, name: str):\n    \"\"\"\n    Start the timer.\n\n    Args:\n        name (str): The name of the timer.\n\n    Raises:\n        NameNotExists: If the timer does not exist.\n    \"\"\"\n    if name not in self._timers:\n        raise NameNotExists(f\"Timer '{name}' does not exist.\")\n    timer = self._timers[name]\n    if timer['start'] is None:\n        timer['start'] = datetime.now()\n        timer['segments'] += 1\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.stop_timer","title":"<code>stop_timer(name)</code>","text":"<p>Stop the timer and accumulate elapsed time.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the timer.</p> required <p>Raises:</p> Type Description <code>NameNotExists</code> <p>If the timer does not exist.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def stop_timer(self, name: str):\n    \"\"\"\n    Stop the timer and accumulate elapsed time.\n\n    Args:\n        name (str): The name of the timer.\n\n    Raises:\n        NameNotExists: If the timer does not exist.\n    \"\"\"\n    if name not in self._timers:\n        raise NameNotExists(f\"Timer '{name}' does not exist.\")\n    timer = self._timers[name]\n    if timer['start'] is not None:\n        now = datetime.now()\n        timer['elapsed'] += (now - timer['start']).total_seconds()\n        timer['stop'] = now\n        timer['start'] = None\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.timer_names","title":"<code>timer_names()</code>","text":"<p>Get the list of timer names.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of timer names.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def timer_names(self) -&gt; list:\n    \"\"\"\n    Get the list of timer names.\n\n    Returns:\n        list: A list of timer names.\n    \"\"\"\n    return list(self._timers.keys())\n</code></pre>"},{"location":"api/stats/#prostata.Stats.Stats.used_names","title":"<code>used_names()</code>","text":"<p>Get the list of all used names.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of all used names across timers, counters, ratios, and attributes.</p> Source code in <code>prostata/Stats.py</code> <pre><code>def used_names(self) -&gt; list:\n    \"\"\"\n    Get the list of all used names.\n\n    Returns:\n        list: A list of all used names across timers, counters, ratios, and attributes.\n    \"\"\"\n    return list(self._names_used)\n</code></pre>"},{"location":"api/stats/#overview","title":"Overview","text":"<p>The <code>Stats</code> class is the main interface for creating and managing statistics in prostata. It provides methods for creating timers, counters, ratios, and attributes, as well as managing their labels and values.</p>"},{"location":"api/stats/#initialization","title":"Initialization","text":"<pre><code>from prostata import Stats\n\nstats = Stats()\n</code></pre>"},{"location":"api/stats/#timer-methods","title":"Timer Methods","text":""},{"location":"api/stats/#set_timername-label","title":"set_timer(name, [label])","text":"<p>Create a new timer statistic.</p> <p>Parameters: - <code>name</code> (str): Unique identifier for the timer - <code>label</code> (str, optional): Display label (defaults to name)</p> <p>Returns: None</p> <p>Raises: - <code>NameNotAllowed</code>: If name contains invalid characters - <code>NameExists</code>: If name already exists</p> <p>Example: <pre><code>stats.set_timer(\"response_time\", \"Response Time\")\n</code></pre></p>"},{"location":"api/stats/#start_timername","title":"start_timer(name)","text":"<p>Start a timer.</p> <p>Parameters: - <code>name</code> (str): Timer name</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If timer doesn't exist</p>"},{"location":"api/stats/#stop_timername","title":"stop_timer(name)","text":"<p>Stop a timer and record the duration.</p> <p>Parameters: - <code>name</code> (str): Timer name</p> <p>Returns: float - Duration in seconds</p> <p>Raises: - <code>NameNotExists</code>: If timer doesn't exist</p>"},{"location":"api/stats/#get_timername","title":"get_timer(name)","text":"<p>Get the current duration of a timer.</p> <p>Parameters: - <code>name</code> (str): Timer name</p> <p>Returns: float - Duration in seconds</p> <p>Raises: - <code>NameNotExists</code>: If timer doesn't exist</p>"},{"location":"api/stats/#reset_timername","title":"reset_timer(name)","text":"<p>Reset a timer to zero.</p> <p>Parameters: - <code>name</code> (str): Timer name</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If timer doesn't exist</p>"},{"location":"api/stats/#counter-methods","title":"Counter Methods","text":""},{"location":"api/stats/#set_countername-initial_value-label","title":"set_counter(name, initial_value, [label])","text":"<p>Create a new counter statistic.</p> <p>Parameters: - <code>name</code> (str): Unique identifier for the counter - <code>initial_value</code> (int): Starting value - <code>label</code> (str, optional): Display label (defaults to name)</p> <p>Returns: None</p> <p>Raises: - <code>NameNotAllowed</code>: If name contains invalid characters - <code>NameExists</code>: If name already exists</p>"},{"location":"api/stats/#increment_countername-amount","title":"increment_counter(name, [amount])","text":"<p>Increment a counter.</p> <p>Parameters: - <code>name</code> (str): Counter name - <code>amount</code> (int, optional): Amount to increment (default: 1)</p> <p>Returns: int - New counter value</p> <p>Raises: - <code>NameNotExists</code>: If counter doesn't exist</p>"},{"location":"api/stats/#decrement_countername-amount","title":"decrement_counter(name, [amount])","text":"<p>Decrement a counter.</p> <p>Parameters: - <code>name</code> (str): Counter name - <code>amount</code> (int, optional): Amount to decrement (default: 1)</p> <p>Returns: int - New counter value</p> <p>Raises: - <code>NameNotExists</code>: If counter doesn't exist</p>"},{"location":"api/stats/#get_countername","title":"get_counter(name)","text":"<p>Get the current value of a counter.</p> <p>Parameters: - <code>name</code> (str): Counter name</p> <p>Returns: int</p> <p>Raises: - <code>NameNotExists</code>: If counter doesn't exist</p>"},{"location":"api/stats/#set_counter_valuename-value","title":"set_counter_value(name, value)","text":"<p>Set a counter to a specific value.</p> <p>Parameters: - <code>name</code> (str): Counter name - <code>value</code> (int): New value</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If counter doesn't exist</p>"},{"location":"api/stats/#reset_countername","title":"reset_counter(name)","text":"<p>Reset a counter to its initial value.</p> <p>Parameters: - <code>name</code> (str): Counter name</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If counter doesn't exist</p>"},{"location":"api/stats/#ratio-methods","title":"Ratio Methods","text":""},{"location":"api/stats/#set_rationame-initial_value-label","title":"set_ratio(name, initial_value, [label])","text":"<p>Create a new ratio statistic.</p> <p>Parameters: - <code>name</code> (str): Unique identifier for the ratio - <code>initial_value</code> (float): Starting value (typically 0.0 to 1.0) - <code>label</code> (str, optional): Display label (defaults to name)</p> <p>Returns: None</p> <p>Raises: - <code>NameNotAllowed</code>: If name contains invalid characters - <code>NameExists</code>: If name already exists</p>"},{"location":"api/stats/#get_rationame","title":"get_ratio(name)","text":"<p>Get the current value of a ratio.</p> <p>Parameters: - <code>name</code> (str): Ratio name</p> <p>Returns: float</p> <p>Raises: - <code>NameNotExists</code>: If ratio doesn't exist</p>"},{"location":"api/stats/#set_ratio_valuename-value","title":"set_ratio_value(name, value)","text":"<p>Set a ratio to a specific value.</p> <p>Parameters: - <code>name</code> (str): Ratio name - <code>value</code> (float): New value</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If ratio doesn't exist</p>"},{"location":"api/stats/#update_rationame-value","title":"update_ratio(name, value)","text":"<p>Update a ratio value (same as set_ratio_value).</p> <p>Parameters: - <code>name</code> (str): Ratio name - <code>value</code> (float): New value</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If ratio doesn't exist</p>"},{"location":"api/stats/#reset_rationame","title":"reset_ratio(name)","text":"<p>Reset a ratio to its initial value.</p> <p>Parameters: - <code>name</code> (str): Ratio name</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If ratio doesn't exist</p>"},{"location":"api/stats/#attribute-methods","title":"Attribute Methods","text":""},{"location":"api/stats/#set_attributename-value-label","title":"set_attribute(name, value, [label])","text":"<p>Create a new attribute.</p> <p>Parameters: - <code>name</code> (str): Unique identifier for the attribute - <code>value</code> (Any): Attribute value (any type) - <code>label</code> (str, optional): Display label (defaults to name)</p> <p>Returns: None</p> <p>Raises: - <code>NameNotAllowed</code>: If name contains invalid characters - <code>NameExists</code>: If name already exists</p>"},{"location":"api/stats/#get_attributename","title":"get_attribute(name)","text":"<p>Get the value of an attribute.</p> <p>Parameters: - <code>name</code> (str): Attribute name</p> <p>Returns: Any - The attribute value</p> <p>Raises: - <code>NameNotExists</code>: If attribute doesn't exist</p>"},{"location":"api/stats/#set_attribute_valuename-value","title":"set_attribute_value(name, value)","text":"<p>Set an attribute to a new value.</p> <p>Parameters: - <code>name</code> (str): Attribute name - <code>value</code> (Any): New value</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If attribute doesn't exist</p>"},{"location":"api/stats/#has_attributename","title":"has_attribute(name)","text":"<p>Check if an attribute exists.</p> <p>Parameters: - <code>name</code> (str): Attribute name</p> <p>Returns: bool</p>"},{"location":"api/stats/#label-methods","title":"Label Methods","text":""},{"location":"api/stats/#set_labelname-label","title":"set_label(name, label)","text":"<p>Set or update the label for any statistic.</p> <p>Parameters: - <code>name</code> (str): Statistic name - <code>label</code> (str): New label</p> <p>Returns: None</p> <p>Raises: - <code>NameNotExists</code>: If statistic doesn't exist</p>"},{"location":"api/stats/#get_labels","title":"get_labels()","text":"<p>Get all labels for all statistics.</p> <p>Returns: dict - Mapping of statistic names to labels</p>"},{"location":"api/stats/#get_labels_for_timers","title":"get_labels_for_timers()","text":"<p>Get labels for all timers.</p> <p>Returns: dict - Mapping of timer names to labels</p>"},{"location":"api/stats/#get_labels_for_counters","title":"get_labels_for_counters()","text":"<p>Get labels for all counters.</p> <p>Returns: dict - Mapping of counter names to labels</p>"},{"location":"api/stats/#get_labels_for_ratios","title":"get_labels_for_ratios()","text":"<p>Get labels for all ratios.</p> <p>Returns: dict - Mapping of ratio names to labels</p>"},{"location":"api/stats/#get_labels_for_attributes","title":"get_labels_for_attributes()","text":"<p>Get labels for all attributes.</p> <p>Returns: dict - Mapping of attribute names to labels</p>"},{"location":"api/stats/#utility-methods","title":"Utility Methods","text":""},{"location":"api/stats/#get_all_stats","title":"get_all_stats()","text":"<p>Get a summary of all statistics.</p> <p>Returns: dict - Summary with counts by type</p>"},{"location":"api/stats/#get_timers","title":"get_timers()","text":"<p>Get all timer names.</p> <p>Returns: list[str]</p>"},{"location":"api/stats/#get_counters","title":"get_counters()","text":"<p>Get all counter names.</p> <p>Returns: list[str]</p>"},{"location":"api/stats/#get_ratios","title":"get_ratios()","text":"<p>Get all ratio names.</p> <p>Returns: list[str]</p>"},{"location":"api/stats/#get_attributes","title":"get_attributes()","text":"<p>Get all attribute names and values.</p> <p>Returns: dict - Mapping of attribute names to values</p>"},{"location":"api/stats/#has_timername","title":"has_timer(name)","text":"<p>Check if a timer exists.</p> <p>Parameters: - <code>name</code> (str): Timer name</p> <p>Returns: bool</p>"},{"location":"api/stats/#has_countername","title":"has_counter(name)","text":"<p>Check if a counter exists.</p> <p>Parameters: - <code>name</code> (str): Counter name</p> <p>Returns: bool</p>"},{"location":"api/stats/#has_rationame","title":"has_ratio(name)","text":"<p>Check if a ratio exists.</p> <p>Parameters: - <code>name</code> (str): Ratio name</p> <p>Returns: bool</p>"},{"location":"api/stats/#exceptions","title":"Exceptions","text":""},{"location":"api/stats/#namenotallowed","title":"NameNotAllowed","text":"<p>Raised when a statistic name contains invalid characters.</p> <p>Valid characters: Letters, numbers, and underscores. Must start with a letter or underscore.</p>"},{"location":"api/stats/#nameexists","title":"NameExists","text":"<p>Raised when trying to create a statistic with a name that already exists.</p>"},{"location":"api/stats/#namenotexists","title":"NameNotExists","text":"<p>Raised when trying to access a statistic that doesn't exist.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>We welcome contributions to prostata! This document outlines the process for contributing to the project.</p>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>Git</li> </ul>"},{"location":"development/contributing/#clone-and-setup","title":"Clone and Setup","text":"<pre><code>git clone https://github.com/merlos/prostata.git\ncd prostata\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=prostata --cov-report=html\n\n# Run specific test file\npytest tests/test_prostata.py\n\n# Run specific test\npytest tests/test_prostata.py::TestStats::test_set_timer\n</code></pre>"},{"location":"development/contributing/#code-quality","title":"Code Quality","text":"<pre><code># Format code\nblack prostata/ tests/\n\n# Sort imports\nisort prostata/ tests/\n\n# Lint code\nflake8 prostata/ tests/\n\n# Type check\nmypy prostata/\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#1-choose-an-issue","title":"1. Choose an Issue","text":"<ul> <li>Check the GitHub Issues for open tasks</li> <li>Comment on the issue to indicate you're working on it</li> <li>Create a new branch for your work</li> </ul>"},{"location":"development/contributing/#2-create-a-branch","title":"2. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/issue-number-description\n</code></pre>"},{"location":"development/contributing/#3-make-changes","title":"3. Make Changes","text":"<ul> <li>Write tests first (TDD approach recommended)</li> <li>Implement your changes</li> <li>Ensure all tests pass</li> <li>Update documentation if needed</li> </ul>"},{"location":"development/contributing/#4-commit-changes","title":"4. Commit Changes","text":"<pre><code># Stage your changes\ngit add .\n\n# Commit with descriptive message\ngit commit -m \"feat: add new feature description\n\n- What was changed\n- Why it was changed\n- Any breaking changes\n\"\n</code></pre>"},{"location":"development/contributing/#5-push-and-create-pr","title":"5. Push and Create PR","text":"<pre><code># Push your branch\ngit push origin feature/your-feature-name\n\n# Create a Pull Request on GitHub\n</code></pre>"},{"location":"development/contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use Black for code formatting</li> <li>Use isort for import sorting</li> <li>Maximum line length: 88 characters (Black default)</li> </ul>"},{"location":"development/contributing/#type-hints","title":"Type Hints","text":"<ul> <li>Use type hints for all function parameters and return values</li> <li>Use <code>typing</code> module for complex types</li> <li>Run <code>mypy</code> to check types</li> </ul>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>Use Google-style docstrings</li> <li>Document all public methods and classes</li> <li>Update documentation for any API changes</li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<ul> <li>Write unit tests for all new functionality</li> <li>Aim for 100% code coverage</li> <li>Use descriptive test names</li> <li>Test edge cases and error conditions</li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"development/contributing/#pr-requirements","title":"PR Requirements","text":"<ul> <li>[ ] All tests pass</li> <li>[ ] Code is formatted with Black</li> <li>[ ] Imports are sorted with isort</li> <li>[ ] No linting errors (flake8)</li> <li>[ ] Type checking passes (mypy)</li> <li>[ ] Documentation updated if needed</li> <li>[ ] Tests added for new functionality</li> </ul>"},{"location":"development/contributing/#pr-description","title":"PR Description","text":"<p>Include: - What changes were made - Why the changes were needed - Any breaking changes - Screenshots/videos for UI changes (if applicable)</p>"},{"location":"development/contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated checks run (tests, linting, etc.)</li> <li>Code review by maintainers</li> <li>Address review comments</li> <li>Merge when approved</li> </ol>"},{"location":"development/contributing/#issue-reporting","title":"Issue Reporting","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, please include:</p> <ul> <li>Python version</li> <li>Operating system</li> <li>Steps to reproduce</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Code sample if possible</li> </ul>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>For feature requests, please include:</p> <ul> <li>Use case description</li> <li>Proposed API</li> <li>Example usage</li> <li>Why this feature would be valuable</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project follows a code of conduct to ensure a welcoming environment for all contributors. By participating, you agree to:</p> <ul> <li>Be respectful and inclusive</li> <li>Focus on constructive feedback</li> <li>Accept responsibility for mistakes</li> <li>Show empathy towards other contributors</li> <li>Help create a positive community</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing to prostata, you agree that your contributions will be licensed under the same license as the project (MIT License).</p>"},{"location":"development/testing/","title":"Testing","text":"<p>Prostata uses comprehensive testing to ensure reliability and maintain code quality.</p>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>Tests are organized in the <code>tests/</code> directory:</p> <pre><code>tests/\n\u251c\u2500\u2500 __init__.py\n\u2514\u2500\u2500 test_prostata.py\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#basic-test-execution","title":"Basic Test Execution","text":"<pre><code># Run all tests\npytest\n\n# Run with verbose output\npytest -v\n\n# Run specific test file\npytest tests/test_prostata.py\n\n# Run specific test class\npytest tests/test_prostata.py::TestStats\n\n# Run specific test method\npytest tests/test_prostata.py::TestStats::test_set_timer\n</code></pre>"},{"location":"development/testing/#coverage-reporting","title":"Coverage Reporting","text":"<pre><code># Generate coverage report\npytest --cov=prostata\n\n# Generate HTML coverage report\npytest --cov=prostata --cov-report=html\n\n# View HTML report (opens in browser)\nopen htmlcov/index.html\n</code></pre>"},{"location":"development/testing/#test-configuration","title":"Test Configuration","text":"<p>Tests use <code>pytest</code> with the following configuration in <code>pyproject.toml</code>:</p> <pre><code>[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"--strict-markers\",\n    \"--strict-config\",\n    \"--verbose\",\n    \"--tb=short\",\n]\n</code></pre>"},{"location":"development/testing/#test-categories","title":"Test Categories","text":""},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<p>Unit tests cover individual components and methods:</p> <ul> <li>Timer Tests: Test timer creation, starting, stopping, and duration calculation</li> <li>Counter Tests: Test counter creation, incrementing, decrementing, and value setting</li> <li>Ratio Tests: Test ratio creation, value setting, and updating</li> <li>Attribute Tests: Test attribute creation, value getting/setting, and type handling</li> <li>Label Tests: Test label setting, updating, and retrieval for all statistic types</li> <li>Dynamic Method Tests: Test automatic method generation and functionality</li> <li>Validation Tests: Test name validation and error handling</li> <li>Exception Tests: Test custom exceptions for various error conditions</li> </ul>"},{"location":"development/testing/#edge-cases","title":"Edge Cases","text":"<p>Tests cover edge cases and error conditions:</p> <ul> <li>Invalid statistic names</li> <li>Duplicate names across types</li> <li>Accessing non-existent statistics</li> <li>Type validation for values</li> <li>Boundary conditions for numeric values</li> </ul>"},{"location":"development/testing/#integration-tests","title":"Integration Tests","text":"<p>Tests verify that components work together correctly:</p> <ul> <li>Mixed statistic types in same instance</li> <li>Dynamic method generation across all types</li> <li>Label management across statistics</li> <li>Bulk operations and queries</li> </ul>"},{"location":"development/testing/#test-coverage","title":"Test Coverage","text":"<p>Current test coverage: 100%</p> <p>Coverage includes: - All public methods - All private helper methods - Error handling paths - Edge cases - Type validation</p>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#test-structure_1","title":"Test Structure","text":"<pre><code>import pytest\nfrom prostata import Stats\n\nclass TestStats:\n    def setup_method(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        self.stats = Stats()\n\n    def test_set_timer_basic(self):\n        \"\"\"Test basic timer creation.\"\"\"\n        self.stats.set_timer(\"test_timer\")\n\n        # Assert timer exists\n        assert self.stats.has_timer(\"test_timer\")\n\n        # Assert dynamic method exists\n        assert hasattr(self.stats, \"get_test_timer\")\n\n    def test_timer_start_stop(self):\n        \"\"\"Test timer start and stop functionality.\"\"\"\n        self.stats.set_timer(\"response_time\")\n\n        # Start timer\n        self.stats.start_response_time()\n\n        # Simulate some work\n        import time\n        time.sleep(0.01)\n\n        # Stop timer\n        duration = self.stats.stop_response_time()\n\n        # Assert duration is positive\n        assert duration &gt; 0\n\n        # Assert duration is reasonable (less than 1 second)\n        assert duration &lt; 1.0\n</code></pre>"},{"location":"development/testing/#test-naming-convention","title":"Test Naming Convention","text":"<ul> <li>Test files: <code>test_*.py</code></li> <li>Test classes: <code>Test*</code></li> <li>Test methods: <code>test_*</code></li> <li>Use descriptive names that explain what is being tested</li> </ul>"},{"location":"development/testing/#assertions","title":"Assertions","text":"<p>Use appropriate assertions for different scenarios:</p> <pre><code># Equality\nassert result == expected\n\n# Identity\nassert result is expected\n\n# Truthiness\nassert result\nassert not result\n\n# Exceptions\nwith pytest.raises(ValueError):\n    invalid_operation()\n\n# Approximate values (for timing)\nassert abs(actual - expected) &lt; tolerance\n\n# Collections\nassert item in collection\nassert len(collection) == expected_length\n</code></pre>"},{"location":"development/testing/#fixtures","title":"Fixtures","text":"<p>Use pytest fixtures for reusable test setup:</p> <pre><code>@pytest.fixture\ndef stats_instance():\n    \"\"\"Provide a fresh Stats instance for each test.\"\"\"\n    return Stats()\n\n@pytest.fixture\ndef populated_stats(stats_instance):\n    \"\"\"Provide a Stats instance with some predefined statistics.\"\"\"\n    stats_instance.set_timer(\"timer1\")\n    stats_instance.set_counter(\"counter1\", 0)\n    stats_instance.set_ratio(\"ratio1\", 0.0)\n    stats_instance.set_attribute(\"attr1\", \"value\")\n    return stats_instance\n\ndef test_something(populated_stats):\n    # Test using the populated stats instance\n    assert populated_stats.has_timer(\"timer1\")\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests run automatically on:</p> <ul> <li>GitHub Actions: On every push and pull request</li> <li>Multiple Python versions: 3.8, 3.9, 3.10, 3.11</li> <li>Multiple operating systems: Ubuntu, macOS, Windows</li> </ul>"},{"location":"development/testing/#ci-configuration","title":"CI Configuration","text":"<p>See <code>.github/workflows/test.yml</code> for the complete CI setup.</p>"},{"location":"development/testing/#test-dependencies","title":"Test Dependencies","text":"<p>Development dependencies include:</p> <ul> <li><code>pytest</code>: Test framework</li> <li><code>pytest-cov</code>: Coverage reporting</li> <li><code>pytest-mock</code>: Mocking utilities (if needed)</li> </ul> <p>Install with:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"development/testing/#running-failed-tests","title":"Running Failed Tests","text":"<pre><code># Run only failed tests\npytest --lf\n\n# Run failed tests with detailed output\npytest --lf -v\n\n# Run failed tests and stop on first failure\npytest --lf -x\n</code></pre>"},{"location":"development/testing/#debugging-with-pdb","title":"Debugging with PDB","text":"<pre><code># Drop into debugger on failure\npytest --pdb\n\n# Drop into debugger on first failure\npytest -x --pdb\n</code></pre>"},{"location":"development/testing/#verbose-output","title":"Verbose Output","text":"<pre><code># Show all output\npytest -s\n\n# Show captured output for failed tests\npytest -rN\n</code></pre>"},{"location":"development/testing/#performance-testing","title":"Performance Testing","text":"<p>For performance-critical code, consider adding benchmarks:</p> <pre><code>import time\n\ndef test_timer_performance(benchmark):\n    \"\"\"Test timer performance under load.\"\"\"\n    stats = Stats()\n    stats.set_timer(\"perf_timer\")\n\n    def run_timer():\n        stats.start_perf_timer()\n        # Simulate work\n        time.sleep(0.001)\n        stats.stop_perf_timer()\n\n    # Benchmark the operation\n    benchmark(run_timer)\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":""},{"location":"development/testing/#test-isolation","title":"Test Isolation","text":"<ul> <li>Each test should be independent</li> <li>Use <code>setup_method</code>/<code>teardown_method</code> for test isolation</li> <li>Don't rely on test execution order</li> </ul>"},{"location":"development/testing/#test-readability","title":"Test Readability","text":"<ul> <li>Use descriptive test names</li> <li>Keep tests focused on one behavior</li> <li>Use comments to explain complex test logic</li> <li>Follow AAA pattern: Arrange, Act, Assert</li> </ul>"},{"location":"development/testing/#test-maintenance","title":"Test Maintenance","text":"<ul> <li>Update tests when changing APIs</li> <li>Remove obsolete tests</li> <li>Keep test code clean and maintainable</li> <li>Review test coverage regularly</li> </ul>"},{"location":"development/testing/#test-performance","title":"Test Performance","text":"<ul> <li>Keep tests fast (target &lt; 100ms per test)</li> <li>Use fixtures for expensive setup</li> <li>Parallelize tests when possible</li> <li>Mock external dependencies</li> </ul>"},{"location":"user-guide/attributes/","title":"Attributes","text":"<p>Attributes store arbitrary values and metadata.</p>"},{"location":"user-guide/attributes/#creating-attributes","title":"Creating Attributes","text":"<pre><code>from prostata import Stats\n\nstats = Stats()\n\n# Create attributes with different value types\nstats.set_attribute(\"version\", \"1.2.3\", \"Application Version\")\nstats.set_attribute(\"debug_mode\", True, \"Debug Mode Enabled\")\nstats.set_attribute(\"timeout\", 30, \"Request Timeout (seconds)\")\nstats.set_attribute(\"config\", {\"host\": \"localhost\", \"port\": 8080}, \"Server Configuration\")\n</code></pre>"},{"location":"user-guide/attributes/#using-attributes","title":"Using Attributes","text":"<pre><code># Get attribute values\nversion = stats.get_attribute(\"version\")\ndebug = stats.get_attribute(\"debug_mode\")\ntimeout = stats.get_attribute(\"timeout\")\nconfig = stats.get_attribute(\"config\")\n\n# Update attribute values\nstats.set_attribute_value(\"version\", \"1.2.4\")\n# or using dynamic method:\nstats.set_version(\"1.2.4\")\n</code></pre>"},{"location":"user-guide/attributes/#attribute-features","title":"Attribute Features","text":""},{"location":"user-guide/attributes/#type-flexibility","title":"Type Flexibility","text":"<p>Attributes can store any Python value:</p> <pre><code># Simple types\nstats.set_attribute(\"count\", 42)\nstats.set_attribute(\"rate\", 0.95)\nstats.set_attribute(\"name\", \"my_app\")\n\n# Complex types\nstats.set_attribute(\"settings\", {\n    \"debug\": True,\n    \"log_level\": \"INFO\",\n    \"features\": [\"auth\", \"cache\", \"metrics\"]\n})\n\nstats.set_attribute(\"callback\", lambda x: x * 2)\n</code></pre>"},{"location":"user-guide/attributes/#dynamic-setters","title":"Dynamic Setters","text":"<p>Like other statistics, attributes get dynamic setter methods:</p> <pre><code>stats.set_attribute(\"status\", \"initializing\")\n\n# These methods are created automatically:\nstats.set_status(\"running\")    # instead of stats.set_attribute_value(\"status\", \"running\")\n</code></pre>"},{"location":"user-guide/attributes/#use-cases","title":"Use Cases","text":"<p>Attributes are useful for:</p> <ul> <li>Configuration values</li> <li>Metadata about your application</li> <li>Status information</li> <li>Computed values that don't fit counters/ratios</li> <li>Complex data structures</li> </ul> <pre><code># Application metadata\nstats.set_attribute(\"app_name\", \"MyApp\")\nstats.set_attribute(\"start_time\", datetime.now())\nstats.set_attribute(\"environment\", \"production\")\n\n# Runtime configuration\nstats.set_attribute(\"max_connections\", 100)\nstats.set_attribute(\"cache_enabled\", True)\n\n# Status information\nstats.set_attribute(\"health_status\", \"healthy\")\nstats.set_attribute(\"last_error\", None)\n</code></pre>"},{"location":"user-guide/attributes/#attribute-labels","title":"Attribute Labels","text":"<pre><code># Get all attribute labels\nattr_labels = stats.get_labels_for_attributes()\n\n# Update an attribute label\nstats.set_label(\"version\", \"Application Version Number\")\n</code></pre>"},{"location":"user-guide/counters/","title":"Counters","text":"<p>Counters track quantities or event counts with increment and decrement operations.</p>"},{"location":"user-guide/counters/#creating-counters","title":"Creating Counters","text":"<pre><code>from prostata import Stats\n\nstats = Stats()\n\n# Create a counter with default values\nstats.set_counter(\"requests\")\n\n# Create a counter with initial value and unit\nstats.set_counter(\"bytes_processed\", 0, \"bytes\", \"Bytes Processed\")\n\n# Create a counter with custom label\nstats.set_counter(\"errors\", 0, \"count\", \"Error Count\")\n</code></pre>"},{"location":"user-guide/counters/#using-counters","title":"Using Counters","text":"<pre><code># Increment by 1\nstats.incr(\"requests\")\n# or using dynamic method:\nstats.incr_requests()\n\n# Increment by specific amount\nstats.incr(\"bytes_processed\", 1024)\n# or using dynamic method:\nstats.incr_bytes_processed(1024)\n\n# Decrement by 1\nstats.decr(\"requests\")\n# or using dynamic method:\nstats.decr_requests()\n\n# Decrement by specific amount\nstats.decr(\"bytes_processed\", 100)\n\n# Get current value\ncount = stats.get_counter(\"requests\")\n# or using dynamic method:\ncount = stats.get_requests()\n\n# Reset to specific value\nstats.reset_counter(\"requests\", 0)\n# or using dynamic method:\nstats.reset_requests(0)\n\n# Change unit\nstats.set_counter_unit(\"bytes_processed\", \"MB\")\n</code></pre>"},{"location":"user-guide/counters/#counter-features","title":"Counter Features","text":""},{"location":"user-guide/counters/#units","title":"Units","text":"<p>Counters can have units for better context:</p> <pre><code>stats.set_counter(\"memory_usage\", 0, \"MB\", \"Memory Usage (MB)\")\nstats.set_counter(\"api_calls\", 0, \"requests\", \"API Call Count\")\nstats.set_counter(\"files_processed\", 0, \"files\", \"Files Processed\")\n</code></pre>"},{"location":"user-guide/counters/#thread-safety","title":"Thread Safety","text":"<p>Thread Safety</p> <p>Counters are not thread-safe by default. If you need to use counters across multiple threads, implement your own locking mechanism.</p>"},{"location":"user-guide/counters/#negative-values","title":"Negative Values","text":"<p>Counters can go negative:</p> <pre><code>stats.set_counter(\"balance\", 100)\nstats.decr_balance(150)  # balance = -50\n</code></pre>"},{"location":"user-guide/counters/#counter-labels","title":"Counter Labels","text":"<pre><code># Get all counter labels\ncounter_labels = stats.get_labels_for_counters()\n\n# Update a counter label\nstats.set_label(\"requests\", \"HTTP Requests\")\n</code></pre>"},{"location":"user-guide/dynamic-methods/","title":"Dynamic Methods","text":"<p>Prostata automatically generates dynamic methods for all your statistics, providing convenient shortcuts for common operations.</p>"},{"location":"user-guide/dynamic-methods/#generated-methods","title":"Generated Methods","text":"<p>For each statistic you create, prostata generates several methods automatically:</p>"},{"location":"user-guide/dynamic-methods/#timer-methods","title":"Timer Methods","text":"<pre><code>stats.set_timer(\"response_time\")\n\n# Generated methods:\nstats.start_response_time()     # Start the timer\nstats.stop_response_time()      # Stop the timer and record duration\nstats.get_response_time()       # Get the current duration\nstats.reset_response_time()     # Reset the timer\n</code></pre>"},{"location":"user-guide/dynamic-methods/#counter-methods","title":"Counter Methods","text":"<pre><code>stats.set_counter(\"requests\", 0)\n\n# Generated methods:\nstats.inc_requests()            # Increment by 1\nstats.inc_requests(5)           # Increment by 5\nstats.dec_requests()            # Decrement by 1\nstats.dec_requests(3)           # Decrement by 3\nstats.get_requests()            # Get current value\nstats.set_requests(100)         # Set to specific value\nstats.reset_requests()          # Reset to initial value\n</code></pre>"},{"location":"user-guide/dynamic-methods/#ratio-methods","title":"Ratio Methods","text":"<pre><code>stats.set_ratio(\"hit_rate\", 0.0)\n\n# Generated methods:\nstats.get_hit_rate()            # Get current ratio\nstats.set_hit_rate(0.95)        # Set ratio value\nstats.update_hit_rate(0.92)     # Update ratio (same as set)\nstats.reset_hit_rate()          # Reset to initial value\n</code></pre>"},{"location":"user-guide/dynamic-methods/#attribute-methods","title":"Attribute Methods","text":"<pre><code>stats.set_attribute(\"version\", \"1.0.0\")\n\n# Generated methods:\nstats.get_version()             # Get attribute value\nstats.set_version(\"1.1.0\")      # Set attribute value\n</code></pre>"},{"location":"user-guide/dynamic-methods/#method-naming-convention","title":"Method Naming Convention","text":"<p>Dynamic methods follow this pattern:</p> <ul> <li><code>start_&lt;name&gt;()</code> - Start a timer</li> <li><code>stop_&lt;name&gt;()</code> - Stop a timer</li> <li><code>get_&lt;name&gt;()</code> - Get the current value</li> <li><code>set_&lt;name&gt;(value)</code> - Set a new value</li> <li><code>reset_&lt;name&gt;()</code> - Reset to initial value</li> <li><code>inc_&lt;name&gt;([amount])</code> - Increment a counter (default amount=1)</li> <li><code>dec_&lt;name&gt;([amount])</code> - Decrement a counter (default amount=1)</li> <li><code>update_&lt;name&gt;(value)</code> - Update a ratio (same as set)</li> </ul>"},{"location":"user-guide/dynamic-methods/#examples","title":"Examples","text":""},{"location":"user-guide/dynamic-methods/#web-server-monitoring","title":"Web Server Monitoring","text":"<pre><code>from prostata import Stats\n\nstats = Stats()\n\n# Set up statistics\nstats.set_counter(\"requests_total\", 0, \"Total Requests\")\nstats.set_counter(\"errors_total\", 0, \"Total Errors\")\nstats.set_timer(\"request_duration\", \"Request Duration\")\nstats.set_ratio(\"error_rate\", 0.0, \"Error Rate\")\nstats.set_attribute(\"server_status\", \"running\", \"Server Status\")\n\n# Handle a request\nstats.inc_requests_total()           # requests_total += 1\nstats.start_request_duration()       # Start timing\n\n# ... process request ...\n\nif error_occurred:\n    stats.inc_errors_total()         # errors_total += 1\n\nstats.stop_request_duration()        # Stop timing\n\n# Update error rate\ntotal_requests = stats.get_requests_total()\ntotal_errors = stats.get_errors_total()\nstats.set_error_rate(total_errors / total_requests if total_requests &gt; 0 else 0)\n\n# Check server status\nstatus = stats.get_server_status()  # \"running\"\n</code></pre>"},{"location":"user-guide/dynamic-methods/#database-connection-pool","title":"Database Connection Pool","text":"<pre><code># Set up pool statistics\nstats.set_counter(\"connections_active\", 0, \"Active Connections\")\nstats.set_counter(\"connections_created\", 0, \"Connections Created\")\nstats.set_attribute(\"pool_size\", 10, \"Pool Size\")\n\ndef get_connection():\n    stats.inc_connections_active()\n    stats.inc_connections_created()\n    # ... get connection logic ...\n    return connection\n\ndef release_connection(conn):\n    stats.dec_connections_active()\n    # ... release logic ...\n\n# Usage\nconn1 = get_connection()  # active: 1, created: 1\nconn2 = get_connection()  # active: 2, created: 2\nrelease_connection(conn1) # active: 1\n</code></pre>"},{"location":"user-guide/dynamic-methods/#benefits","title":"Benefits","text":""},{"location":"user-guide/dynamic-methods/#convenience","title":"Convenience","text":"<p>Dynamic methods provide shortcuts without remembering method names:</p> <pre><code># Instead of:\nstats.increment_counter(\"requests\", 1)\nstats.set_attribute_value(\"status\", \"busy\")\n\n# You can use:\nstats.inc_requests()\nstats.set_status(\"busy\")\n</code></pre>"},{"location":"user-guide/dynamic-methods/#type-safety","title":"Type Safety","text":"<p>Methods are generated based on the statistic type, providing appropriate operations:</p> <pre><code># Timers get start/stop methods\nstats.start_response_time()\nstats.stop_response_time()\n\n# Counters get inc/dec methods\nstats.inc_requests()\nstats.dec_requests()\n\n# Ratios get update methods\nstats.update_hit_rate(0.95)\n</code></pre>"},{"location":"user-guide/dynamic-methods/#ide-support","title":"IDE Support","text":"<p>Dynamic methods enable better IDE autocompletion and type checking.</p>"},{"location":"user-guide/dynamic-methods/#method-availability","title":"Method Availability","text":"<p>Dynamic methods are available immediately after creating a statistic:</p> <pre><code>stats = Stats()\n\n# Method doesn't exist yet\n# stats.get_my_counter()  # AttributeError\n\nstats.set_counter(\"my_counter\", 0)\n\n# Now the method exists\nstats.get_my_counter()  # 0\nstats.inc_my_counter()  # 1\n</code></pre>"},{"location":"user-guide/dynamic-methods/#error-handling","title":"Error Handling","text":"<p>If you try to use a dynamic method for a non-existent statistic, you'll get an <code>AttributeError</code>:</p> <pre><code>stats = Stats()\nstats.get_unknown_stat()  # AttributeError: 'Stats' object has no attribute 'get_unknown_stat'\n</code></pre> <p>Use the main API methods if you need to handle missing statistics gracefully:</p> <pre><code># Safe access\ntry:\n    value = stats.get_my_stat()\nexcept AttributeError:\n    value = None\n\n# Or use the main API\nif stats.has_counter(\"my_stat\"):\n    value = stats.get_counter(\"my_stat\")\n</code></pre>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>Welcome to prostata! This guide will help you get started with tracking statistics in your Python applications.</p>"},{"location":"user-guide/getting-started/#installation","title":"Installation","text":"<p>Install prostata using pip:</p> <pre><code>pip install prostata\n</code></pre>"},{"location":"user-guide/getting-started/#basic-usage","title":"Basic Usage","text":"<pre><code>from prostata import Stats\n\n# Create a stats instance\nstats = Stats()\n\n# Create different types of statistics\nstats.set_timer(\"operation_time\", \"Operation Duration\")\nstats.set_counter(\"items_processed\", 0, \"count\", \"Items Processed\")\nstats.set_attribute(\"version\", \"1.0.0\", \"Application Version\")\n\n# Use the statistics\nstats.start_operation_time()\n# ... do some work ...\nstats.incr_items_processed(5)\nstats.stop_operation_time()\n\n# Get results\nduration = stats.get_operation_time()\ncount = stats.get_items_processed()\nversion = stats.get_version()\n</code></pre>"},{"location":"user-guide/getting-started/#types-of-statistics","title":"Types of Statistics","text":""},{"location":"user-guide/getting-started/#timers","title":"Timers","text":"<p>Track elapsed time between start and stop events.</p>"},{"location":"user-guide/getting-started/#counters","title":"Counters","text":"<p>Count occurrences or quantities with increment/decrement operations.</p>"},{"location":"user-guide/getting-started/#ratios","title":"Ratios","text":"<p>Calculate ratios between two counters automatically.</p>"},{"location":"user-guide/getting-started/#attributes","title":"Attributes","text":"<p>Store arbitrary values and metadata.</p>"},{"location":"user-guide/getting-started/#labels","title":"Labels","text":"<p>All statistics can have descriptive labels that default to their names:</p> <pre><code># Custom label\nstats.set_timer(\"db_query\", \"Database Query Time\")\n\n# Default label (same as name)\nstats.set_counter(\"requests\")  # label = \"requests\"\n</code></pre>"},{"location":"user-guide/getting-started/#dynamic-methods","title":"Dynamic Methods","text":"<p>prostata automatically creates convenient methods for each statistic:</p> <pre><code>stats.set_timer(\"load_time\")\nstats.set_counter(\"items\")\n\n# These methods are created automatically:\nstats.start_load_time()    # instead of stats.start_timer(\"load_time\")\nstats.incr_items()         # instead of stats.incr(\"items\")\n</code></pre>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Timers</li> <li>Learn about Counters</li> <li>Learn about Ratios</li> <li>Learn about Attributes</li> <li>Learn about Labels</li> <li>Check the API Reference</li> </ul>"},{"location":"user-guide/labels/","title":"Labels","text":"<p>Labels provide descriptive names for your statistics, making them more readable and self-documenting.</p>"},{"location":"user-guide/labels/#creating-labels","title":"Creating Labels","text":"<p>Labels are set when creating statistics and default to the statistic name:</p> <pre><code>from prostata import Stats\n\nstats = Stats()\n\n# Default labels (same as name)\nstats.set_timer(\"response_time\")        # label = \"response_time\"\nstats.set_counter(\"requests\")           # label = \"requests\"\n\n# Custom labels\nstats.set_timer(\"db_query\", \"Database Query Time\")\nstats.set_counter(\"errors\", 0, \"count\", \"Error Count\")\nstats.set_attribute(\"version\", \"1.0.0\", \"Application Version\")\n</code></pre>"},{"location":"user-guide/labels/#managing-labels","title":"Managing Labels","text":"<pre><code># Update existing labels\nstats.set_label(\"response_time\", \"HTTP Response Time\")\nstats.set_label(\"requests\", \"Total HTTP Requests\")\n\n# Get labels for specific types\ntimer_labels = stats.get_labels_for_timers()\ncounter_labels = stats.get_labels_for_counters()\nratio_labels = stats.get_labels_for_ratios()\nattr_labels = stats.get_labels_for_attributes()\n\n# Get all labels\nall_labels = stats.get_labels()\n</code></pre>"},{"location":"user-guide/labels/#label-features","title":"Label Features","text":""},{"location":"user-guide/labels/#uniqueness","title":"Uniqueness","text":"<p>Names must be unique across all statistic types, but labels can be repeated:</p> <pre><code># This works - same label, different names/types\nstats.set_timer(\"query_time\", \"Database Operation\")\nstats.set_counter(\"query_count\", \"Database Operation\")\nstats.set_attribute(\"query_status\", \"idle\", \"Database Operation\")\n</code></pre>"},{"location":"user-guide/labels/#display-names","title":"Display Names","text":"<p>Labels are useful for display purposes:</p> <pre><code># Instead of showing technical names:\nprint(\"Statistics:\")\nfor name, label in stats.get_labels().items():\n    value = getattr(stats, f'get_{name}')()\n    print(f\"  {label}: {value}\")\n</code></pre> <p>Output: <pre><code>Statistics:\n  HTTP Response Time: 0.123\n  Total HTTP Requests: 42\n  Error Count: 2\n  Application Version: 1.0.0\n</code></pre></p>"},{"location":"user-guide/labels/#internationalization","title":"Internationalization","text":"<p>Labels can be used for i18n:</p> <pre><code># English\nstats.set_timer(\"response_time\", \"Response Time\")\n\n# Spanish\nstats.set_timer(\"response_time\", \"Tiempo de Respuesta\")\n\n# French\nstats.set_timer(\"response_time\", \"Temps de R\u00e9ponse\")\n</code></pre>"},{"location":"user-guide/labels/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/labels/#descriptive-labels","title":"Descriptive Labels","text":"<p>Use clear, descriptive labels:</p> <pre><code># Good\nstats.set_counter(\"http_requests\", \"HTTP Requests\")\nstats.set_timer(\"db_query_time\", \"Database Query Duration\")\n\n# Less clear\nstats.set_counter(\"req\", \"req\")\nstats.set_timer(\"time\", \"time\")\n</code></pre>"},{"location":"user-guide/labels/#consistent-naming","title":"Consistent Naming","text":"<p>Establish naming conventions for your project:</p> <pre><code># Consistent patterns\nstats.set_counter(\"cache_hits\", \"Cache Hits\")\nstats.set_counter(\"cache_misses\", \"Cache Misses\")\nstats.set_counter(\"cache_hit_rate\", \"Cache Hit Rate\")  # ratio\n\n# Or with prefixes\nstats.set_counter(\"http_requests_total\", \"Total HTTP Requests\")\nstats.set_counter(\"http_requests_errors\", \"HTTP Error Requests\")\n</code></pre>"},{"location":"user-guide/labels/#label-updates","title":"Label Updates","text":"<p>Labels can be updated at runtime:</p> <pre><code>stats.set_attribute(\"status\", \"initializing\", \"System Status\")\n\n# Later...\nstats.set_label(\"status\", \"System Health Status\")\nstats.set_attribute_value(\"status\", \"healthy\")\n</code></pre>"},{"location":"user-guide/ratios/","title":"Ratios","text":"<p>Ratios calculate the relationship between two counters automatically.</p>"},{"location":"user-guide/ratios/#creating-ratios","title":"Creating Ratios","text":"<pre><code>from prostata import Stats\n\nstats = Stats()\n\n# Create the counters first\nstats.set_counter(\"success\", 95, \"count\", \"Successful Operations\")\nstats.set_counter(\"total\", 100, \"count\", \"Total Operations\")\n\n# Create a ratio\nstats.set_ratio(\"success_rate\", \"success\", \"total\", \"Success Rate\")\n</code></pre>"},{"location":"user-guide/ratios/#using-ratios","title":"Using Ratios","text":"<pre><code># Update counter values\nstats.incr_success(5)  # success = 100\nstats.incr_total(10)   # total = 110\n\n# Get the ratio (calculated automatically)\nrate = stats.get_ratio(\"success_rate\")\n# or using dynamic method:\nrate = stats.get_success_rate()\n\nprint(f\"Success rate: {rate:.1%}\")  # Success rate: 90.9%\n</code></pre>"},{"location":"user-guide/ratios/#ratio-features","title":"Ratio Features","text":""},{"location":"user-guide/ratios/#automatic-calculation","title":"Automatic Calculation","text":"<p>Ratios are calculated on-demand using the current counter values:</p> <pre><code># Ratio = numerator / denominator\n# If denominator = 0, ratio = 0.0\n\nstats.set_counter(\"errors\", 3)\nstats.set_counter(\"requests\", 100)\nstats.set_ratio(\"error_rate\", \"errors\", \"requests\")\n\nprint(stats.get_error_rate())  # 0.03\n</code></pre>"},{"location":"user-guide/ratios/#dynamic-updates","title":"Dynamic Updates","text":"<p>Ratios reflect current counter values:</p> <pre><code>stats.set_counter(\"passed\", 8)\nstats.set_counter(\"total\", 10)\nstats.set_ratio(\"pass_rate\", \"passed\", \"total\")\n\nprint(stats.get_pass_rate())  # 0.8\n\nstats.incr_passed(1)\nstats.incr_total(1)\nprint(stats.get_pass_rate())  # 0.818...\n</code></pre>"},{"location":"user-guide/ratios/#use-cases","title":"Use Cases","text":"<p>Common ratio patterns:</p> <pre><code># Error rates\nstats.set_ratio(\"error_rate\", \"errors\", \"requests\")\n\n# Success rates\nstats.set_ratio(\"success_rate\", \"success\", \"attempts\")\n\n# Cache hit rates\nstats.set_ratio(\"cache_hit_rate\", \"cache_hits\", \"cache_requests\")\n\n# Conversion rates\nstats.set_ratio(\"conversion_rate\", \"conversions\", \"visitors\")\n</code></pre>"},{"location":"user-guide/ratios/#ratio-labels","title":"Ratio Labels","text":"<pre><code># Get all ratio labels\nratio_labels = stats.get_labels_for_ratios()\n\n# Update a ratio label\nstats.set_label(\"success_rate\", \"Operation Success Rate\")\n</code></pre>"},{"location":"user-guide/timers/","title":"Timers","text":"<p>Timers allow you to track elapsed time between start and stop events.</p>"},{"location":"user-guide/timers/#creating-timers","title":"Creating Timers","text":"<pre><code>from prostata import Stats\n\nstats = Stats()\n\n# Create a timer with default label\nstats.set_timer(\"response_time\")\n\n# Create a timer with custom label\nstats.set_timer(\"db_query\", \"Database Query Time\")\n</code></pre>"},{"location":"user-guide/timers/#using-timers","title":"Using Timers","text":"<pre><code># Start timing\nstats.start_timer(\"response_time\")\n# or using dynamic method:\nstats.start_response_time()\n\n# Do some work\nimport time\ntime.sleep(0.1)\n\n# Stop timing\nstats.stop_timer(\"response_time\")\n# or using dynamic method:\nstats.stop_response_time()\n\n# Get elapsed time in seconds\nelapsed = stats.get_timer(\"response_time\")\n# or using dynamic method:\nelapsed = stats.get_response_time()\n\nprint(f\"Elapsed time: {elapsed:.2f} seconds\")\n</code></pre>"},{"location":"user-guide/timers/#timer-features","title":"Timer Features","text":""},{"location":"user-guide/timers/#multiple-segments","title":"Multiple Segments","text":"<p>Timers can be started and stopped multiple times, accumulating total time:</p> <pre><code>stats.set_timer(\"work_time\")\n\nstats.start_work_time()\ntime.sleep(0.1)\nstats.stop_work_time()\n\nstats.start_work_time()\ntime.sleep(0.2)\nstats.stop_work_time()\n\ntotal_time = stats.get_work_time()  # 0.3 seconds\n</code></pre>"},{"location":"user-guide/timers/#running-timers","title":"Running Timers","text":"<p>You can check elapsed time while a timer is still running:</p> <pre><code>stats.set_timer(\"operation\")\nstats.start_operation()\n\ntime.sleep(0.5)\ncurrent_elapsed = stats.get_operation()  # ~0.5 seconds\n\ntime.sleep(0.5)\nstats.stop_operation()\nfinal_elapsed = stats.get_operation()  # ~1.0 seconds\n</code></pre>"},{"location":"user-guide/timers/#never-started-timers","title":"Never Started Timers","text":"<p>Timers that haven't been started return 0:</p> <pre><code>stats.set_timer(\"unused\")\nelapsed = stats.get_unused()  # 0.0\n</code></pre>"},{"location":"user-guide/timers/#timer-labels","title":"Timer Labels","text":"<pre><code># Get all timer labels\ntimer_labels = stats.get_labels_for_timers()\nprint(timer_labels)  # {'response_time': 'response_time', 'db_query': 'Database Query Time'}\n\n# Update a timer label\nstats.set_label(\"response_time\", \"HTTP Response Time\")\n</code></pre>"}]}